[
["index.html", "3 Seas 37 - Fishes 1 Intro", " 3 Seas 37 - Fishes Kosmas Hench 2019-02-07 1 Intro Here are some scripts to help with the data analysis: how to create a map including piecharts how to do an NMDS plot and run a PERMANOVA To run these, please make sure you have the following R packages installed: # Fundamental packages install.packages(&quot;tidyverse&quot;) install.packages(&quot;vegan&quot;) # ggplot extensions install.packages(&quot;ggalt&quot;) install.packages(&quot;scatterpie&quot;) install.packages(&quot;cowplot&quot;) # Mapping packages install.packages(&quot;ggmap&quot;) install.packages(&quot;sf&quot;) install.packages(&quot;maptools&quot;) install.packages(&quot;rnaturalearth&quot;) install.packages(&quot;rnaturalearthdata&quot;) Following the conventions of the tidyverse, some aspects that you might be used from base R might look a little different: First of all, the tidyverse comes with a few functions that replace common standard functions to achieve a more consistent behavior than base R. This means that here we will use for example read_delim() (tidyverse) instead of read.table() (base R). The second thing that migh need some getting used to is the use of the pipe (%&gt;%): The pipe is an elegant way of connecting severeal functions that are executed one after the other. If we for example have a silly function that simply addes 1 to an input value, there are several ways to get from 1 to 4: add_1 &lt;- function(x){x + 1} a &lt;- 1 b &lt;- add_1(a) c &lt;- add_1(b) d &lt;- add_1(c) d ## [1] 4 add_1(add_1(add_1(1))) ## [1] 4 1 %&gt;% add_1() %&gt;% add_1() %&gt;% add_1() ## [1] 4 Of these three versions I usually find the pipe to be most clear and easily understandable way (especially if you try to make sense of your code when you come back a little while later). Therefore you will see many pipes thoughout the scripts. Further really useful help on R is given by Hadley Wickham in his online book “R for Data Science”. Further helpful information on ggplot2 can be found at: the R Graphics cook book a tutorial by the Harvad University this page by Zev Ross Also, this platform of ggplot extensions is definitively worth a look. "],
["pie-map-template.html", "2 Pie map template", " 2 Pie map template This template is based on the methods form the Hench et al. (2017) paper which compares hamlet observation at Puerto Rico reefs from 2000 (by Aguilar et al. 2003) and from 2017. The data that is used is completely made up though. Here we will generate a map of the sampling area including pie charts that represent a species community. We will make heavy use of ggplot2 package and several of its extensions (ggmap, scatterpie, cowplot). Further more we will need the grid packages and some of the Geo R packages: sf, maptools, rnaturalearth and rnaturalearthdata. To start our R session we have to load the required R packages and set up our working environment: library(tidyverse) library(ggmap) library(scatterpie) library(cowplot) library(sf) library(maptools) library(rnaturalearth) library(rnaturalearthdata) source(&#39;pie_map/functions.R&#39;) Then we have to read in the data (provided in the pie_map data folder). The original data contains the observations as well as meta data (sampling location and coordinates): data &lt;- read_delim(&#39;pie_map/data/sampling_spots.csv&#39;, delim = &#39;\\t&#39;) %&gt;% mutate(all = spec1 + spec2 + spec3 + spec4) Latittude Longitude spot spec1 spec2 spec3 spec4 all 9.3594 -82.2774 Casa_blanca 1 7 2 0 10 9.3014 -82.2941 Punta_Juan 2 3 0 3 8 9.2487 -82.2944 Mangrove_point 2 4 0 2 8 9.2441 -82.1038 Rhino_reef 6 0 0 4 10 9.3181 -82.2218 Solarte_sur 0 3 7 0 10 We will now define the limits of our map and read in the detailed shape-file. This file can be downloaded from gadm.org and copied to the data folder. After the data download the pie_map folder should look like this pie_map ├── data │   ├── geography │   │   ├── PAN_adm0.dbf │   │   ├── PAN_adm0.prj │   │   ├── PAN_adm0.sbn │   │   ├── PAN_adm0.sbx │   │   ├── PAN_adm0.shp │   │   ├── PAN_adm0.shx │   │   └── README.md │   └── sampling_spots.csv ├── functions.R └── README.md After loading the shape-file, we are going to clip it according to the previously defined map boundaries: # setting map boundaries xlim = c(-82.5, -82); ylim = c(9.1, 9.47) # reading in Panama shapefile panama &lt;- sf::st_read(&#39;pie_map/data/geography/PAN_adm0.shp&#39;) bb &lt;- bbox(xlim, ylim) panama_cliped &lt;- st_intersection(bb, panama) #reformating shapefile to work with ggplot2 Next we will prepare our labels for the pie charts and set the color for the land masses on the map. # definig species label for legend spec_labs &lt;- expression(italic(&quot;Spec 1&quot;), italic(&quot;Spec 2&quot;), italic(&quot;Spec 3&quot;), italic(&quot;Spec 4&quot;)) # setting colors for the land mass cFILL &lt;- rgb(.2, .2, .2) Then we are going to produce the main map: plot1 &lt;- ggplot()+ # plot the land mass geom_sf(panama, mapping = aes(), fill = cFILL, col = &#39;black&#39;)+ coord_sf(xlim = xlim, ylim = ylim)+ # plot the pies geom_scatterpie(aes(x = Longitude, y = Latittude, group = spot, r = sqrt(all/1250)/pi), data = data, cols = c(&quot;spec1&quot;, &quot;spec2&quot;, &quot;spec3&quot;, &quot;spec4&quot;), color = rgb(0, 0, 0, 0), lwd = .3)+ scale_fill_viridis_d(name = &#39;Species&#39;, label = spec_labs)+ # add points to the exact sampling points geom_point(data = data, aes(x = Longitude, y = Latittude), shape = 21, fill = &#39;white&#39;, size = 2)+ # the lines below adds labels - this will probably look messy, #but it can be sorted using inkscape or adobe illustrator # geom_text(data = data, aes(x = Longitude, y = Latittude, label = spot), size = 3)+ # add compass geom_north(xscale = 1.5, lon = -82.48, lat = 9.35, fill = &#39;white&#39;, col = &#39;black&#39;)+ # add scale bar scaleBar(lon = -82.12, lat = 9.115, distanceLon = 5, distanceLat = .7, distanceLegend = -1, dist.unit = &quot;km&quot;, orientation = F, rec2.fill = cFILL, legend.size = 2)+ # layout theme_minimal()+ theme(legend.position = c(.85, .85)) Then we are going to create a secondary map to indicate the general position within the Caribbean. For this, we first are going to define the boundaries of the secondary map and than we are going to load the world data (from the rnaturalearthdata package). # settings for Caribbean overview xlimW = c(-93, -55); ylimW = c(5, 24) world &lt;- ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) # Caribbean map: plot2 &lt;- ggplot() + geom_sf(data = world, fill = cFILL, col = rgb(1, 1, 1, .2))+ coord_sf(xlim = xlimW, ylim = ylimW, datum = NA)+ geom_point(data = data[1, ], aes(x = Longitude, y = Latittude), fill = rgb(.9, .3, .3), shape = 22, size = 5, col = &#39;black&#39;)+ theme_void()+ theme(panel.background = element_rect(fill = &#39;white&#39;, color = &#39;black&#39;)) Finally, we use the cowplot package to combine the two plots: If we want, we can now export the map and tweak last details using inkscape or adobe illustrator (this can be useful if pie charts are overlapping or labels are messy): ggsave(&#39;pie_map.pdf&#39;, width = 8, height = 6, device = cairo_pdf) References "],
["nmdspermanova-template.html", "3 NMDS/PERMANOVA template 3.1 NMDS 3.2 PERMANOVA", " 3 NMDS/PERMANOVA template This template is based on the methods from the Hench et al. (2017) paper which compares hamlet observation at Puerto Rico reefs from 2000 (by Aguilar et al. 2003) and from 2017. The data that is used is completely made up though. Here we will generate NMDS plots and run a PERMANOVA to test the significance between the different clusters of three fictional reef types. Most of the analysis makes use of the functions provided by the vegan package (mostly metaMDS() and adonis()). Plotting is done using the ggplot2 package (included in tidyverse) with the extension packages cowplot and ggalt. To start our R session we have to load the required R packages and set up our working environment: library(vegan) library(tidyverse) library(cowplot) library(ggalt) darken &lt;- function(color, factor = 1.4){ col &lt;- col2rgb(color) col &lt;- col/factor col &lt;- rgb(t(col), maxColorValue = 255) col } Then we have to read in the data (provided in the data folder). The original data contains the observations as well as meta data (sampling location and and sample group): data &lt;- read_delim(&#39;permanova/data/more_sampling_spots.csv&#39;, delim = &#39;\\t&#39;) %&gt;% select(-Latittude, -Longitude) spot group spec1 spec2 spec3 spec4 STRI_point gr1 1 4 5 1 Casa_blanca gr1 1 3 4 0 Punta_Juan gr2 5 0 1 4 Punta_Caracol gr1 0 3 3 3 Mangrove_point gr3 2 5 0 2 Moguls gr2 5 2 0 5 Rhino_reef gr2 4 2 1 2 Sophies_reef gr1 1 3 7 0 Sunken_catamaran gr3 4 5 0 2 San_Cristobal gr3 1 3 1 3 Casa_verde gr3 3 3 0 5 Solarte_sur gr2 5 0 2 3 3.1 NMDS To be able execute the NMDS the species observations need to be exported as a matrix object. Here we are going to run the NMDS based on the Bray-Curtis distance between the samples using a max of 500 iterations. dataM &lt;- data %&gt;% select(spec1:spec4) %&gt;% as.matrix() rownames(dataM) &lt;- data$spot NMDSout &lt;- metaMDS(dataM, k = 2, trymax = 500, distance = &#39;bray&#39;) After we ran the NMDS, we have to export the scores both of the samples as well as of the species for plotting in ggplot2: First, we extract the sample scores to a data.frame object using the scores() function from the vegan package and add a column to include the samples names. Than we do the same for the species. Finally, we merge the sample scores back to our original data set. data.scores &lt;- as.data.frame(scores(NMDSout)) data.scores$spot &lt;- rownames(data.scores) species.scores &lt;- as.data.frame(scores(NMDSout, &quot;species&quot;)) species.scores$species &lt;- rownames(species.scores) data &lt;- data %&gt;% left_join(data.scores) ## Joining, by = &quot;spot&quot; Now, we can plot the results of the NMDS using ggplot2: # initializing the plot ggplot(data, aes(x = NMDS1, y = NMDS2, group = group)) + # fixed aspect ration for x and y scale coord_equal() + # adding line ad x = 0 and y = 0 geom_hline(yintercept = 0, color = &#39;lightgray&#39;)+ geom_vline(xintercept = 0, color = &#39;lightgray&#39;)+ # add the species labels geom_text(inherit.aes = F, data = species.scores, aes(x = NMDS1, y = NMDS2, label = species), col = &#39;red&#39;) + # add the sample positions geom_point(aes(colour = group), size = 3) + # add the outer hull of the three groups (function from the ggalt package) geom_encircle(aes(colour = group, fill = group), s_shape = 1, alpha = 0.2, size = 1, expand = 0)+ # add the sample labels geom_text(aes(label = spot), size = 4, vjust = 0, nudge_y = .02) + # change the coler map (from the hrbrthemes package) scale_x_continuous(expand = c(.1, .1))+ theme_minimal()+ theme(panel.grid = element_blank()) 3.2 PERMANOVA Although we can visually inspect our NMDS plot for differences between our 3 groups, we do not know yet whether those differences are statistically significant. To find out about this we need to run a permanova on our data. Yet, before we start, we need to check if the assumptions for permanova are met by the data (Anderson 2001): “The only assumption of the test is that […] the observations are independent and that they have similar distributions” To check for homogeneous dispersion, we can either use a statistical test (permutation test) or visualize the dispersion. Either way, first we need to create the distance matrix (again, since it was not stored before but only computed internally within the metaMDS() function…). Then we also need to find out in which order the sites are stored within the distance matrix (the order may differ from the original data) to assign the groups correctly. Than the beta dispersion can be computed and compared. # compute Bray-Curtis distance dM &lt;- vegdist(dataM, distance = &#39;bray&#39;) # get order of samples gO &lt;- data[match(labels(dM), data$spot), ]$group # compute beta dispersion of the 3 groups betaM &lt;- betadisper(dM, gO) # statistical test for homogeneous dispersion permutest(betaM) ## ## Permutation test for homogeneity of multivariate dispersions ## Permutation: free ## Number of permutations: 999 ## ## Response: Distances ## Df Sum Sq Mean Sq F N.Perm Pr(&gt;F) ## Groups 2 0.002086 0.0010430 0.1771 999 0.84 ## Residuals 9 0.053012 0.0058903 # visual check for homogeneous dispersion ggplot(data.frame(group = betaM$group, distance = betaM$distances), aes(x = group, fill = group, y = distance))+ geom_boxplot()+ ggtitle(&#39;Beta dispersion&#39;)+ theme_minimal() If the dispersion is sufficiently homogeneous, we can finally run the PERMANOVA on the data (using the adonis() function from the vegan package): permM &lt;- adonis(formula = dM ~ gO, permutations = 1999, method = &#39;bray&#39;) print(permM) ## ## Call: ## adonis(formula = dM ~ gO, permutations = 1999, method = &quot;bray&quot;) ## ## Permutation: free ## Number of permutations: 1999 ## ## Terms added sequentially (first to last) ## ## Df SumsOfSqs MeanSqs F.Model R2 Pr(&gt;F) ## gO 2 0.87737 0.43869 13.183 0.74552 5e-04 *** ## Residuals 9 0.29948 0.03328 0.25448 ## Total 11 1.17685 1.00000 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 A last thing we might want to do, is to get an overview over the Permutation Results from our PERMANOVA. We can compare our real case to the distribution created by the permutations: plot_clr &lt;- rgb(1, .5, 0) # export the summary statistics from the PERMANOVA run permOUT &lt;- permustats(permM) # transform into da data.frame permDF &lt;- permOUT$permutations %&gt;% as_tibble() %&gt;% setNames(., nm = &#39;Permutations&#39;) # plotting ggplot(permDF, aes(x = Permutations))+ # add the distribution frm the permutations geom_density(fill = plot_clr)+ geom_point(aes(y = 0), shape = 21, fill = darken(plot_clr, 2.5))+ # add our realized value geom_vline(xintercept = permOUT$statistic, col = darken(plot_clr, 2.5))+ # expand x scale scale_x_continuous(limits = c(-1, 15))+ # plot title ggtitle(&#39;Permutation test&#39;)+ theme_minimal() References "],
["references.html", "4 References", " 4 References "]
]
